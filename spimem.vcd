$date
	Wed Nov  1 21:09:35 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testMemory $end
$var wire 1 ! miso_pin $end
$var reg 7 " address [6:0] $end
$var reg 1 # clk $end
$var reg 1 $ cs_pin $end
$var reg 8 % data [7:0] $end
$var reg 1 & dutpassed $end
$var reg 32 ' i [31:0] $end
$var reg 1 ( mosi_pin $end
$var reg 1 ) sclk_pin $end
$scope module dut $end
$var wire 1 # clk $end
$var wire 1 $ cs_pin $end
$var wire 4 * leds [3:0] $end
$var wire 1 ( mosi_pin $end
$var wire 1 ) sclk_pin $end
$var wire 1 + shift_sOut $end
$var wire 8 , shift_pOut [7:0] $end
$var wire 1 - sclk_pos $end
$var wire 1 . sclk_neg $end
$var wire 1 / mosi $end
$var wire 8 0 mem_out [7:0] $end
$var wire 1 1 cs $end
$var reg 7 2 addressReg [6:0] $end
$var reg 5 3 bitsTx [4:0] $end
$var reg 1 4 load_mem $end
$var reg 1 5 load_shift $end
$var reg 1 ! miso_pin $end
$var reg 3 6 state [2:0] $end
$scope module cscond $end
$var wire 1 # clk $end
$var wire 1 $ noisysignal $end
$var reg 1 1 conditioned $end
$var reg 3 7 counter [2:0] $end
$var reg 1 8 negativeedge $end
$var reg 1 9 positiveedge $end
$var reg 1 : synchronizer0 $end
$var reg 1 ; synchronizer1 $end
$upscope $end
$scope module mem $end
$var wire 7 < address [6:0] $end
$var wire 1 # clk $end
$var wire 1 4 writeEnable $end
$var wire 8 = dataIn [7:0] $end
$var reg 8 > dataOut [7:0] $end
$upscope $end
$scope module mosicond $end
$var wire 1 # clk $end
$var wire 1 ( noisysignal $end
$var reg 1 / conditioned $end
$var reg 3 ? counter [2:0] $end
$var reg 1 @ negativeedge $end
$var reg 1 A positiveedge $end
$var reg 1 B synchronizer0 $end
$var reg 1 C synchronizer1 $end
$upscope $end
$scope module sclkcond $end
$var wire 1 # clk $end
$var wire 1 ) noisysignal $end
$var reg 1 D conditioned $end
$var reg 3 E counter [2:0] $end
$var reg 1 . negativeedge $end
$var reg 1 - positiveedge $end
$var reg 1 F synchronizer0 $end
$var reg 1 G synchronizer1 $end
$upscope $end
$scope module shiftReg $end
$var wire 1 # clk $end
$var wire 8 H parallelDataIn [7:0] $end
$var wire 8 I parallelDataOut [7:0] $end
$var wire 1 J parallelLoad $end
$var wire 1 - peripheralClkEdge $end
$var wire 1 K serialDataIn $end
$var wire 1 + serialDataOut $end
$var reg 8 L shiftregistermem [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx L
zK
zJ
bx I
bz H
0G
0F
b0 E
xD
0C
0B
xA
x@
b0 ?
bx >
bx =
b0 <
0;
0:
x9
x8
b0 7
b0 6
05
04
b0 3
b0 2
x1
bx 0
x/
x.
x-
bx ,
x+
bz *
0)
0(
bx '
1&
bx %
1$
0#
bx "
z!
$end
#100
0$
#200
1)
1(
b0 '
b11110000 %
b1010101 "
#300
0(
b1 '
1)
#400
1(
b10 '
1)
#500
0(
b11 '
1)
#600
1(
b100 '
1)
#700
0(
b101 '
1)
#800
1(
b110 '
1)
#900
0(
b111 '
1)
#1000
b0 '
1)
#1100
b1 '
1)
#1200
b10 '
1)
#1300
b11 '
1)
#1400
1(
b100 '
1)
#1500
b101 '
1)
#1600
b110 '
1)
#1700
b111 '
1)
#1800
b0 '
1)
#1900
0(
b1 '
1)
#2000
1(
b10 '
1)
#2100
0(
b11 '
1)
#2200
1(
b100 '
1)
#2300
0(
b101 '
1)
#2400
1(
b110 '
1)
#2500
0(
b111 '
1)
#2600
0&
b0 '
1)
